import {RawIntegrationParameters} from "../raw";

export class IntegrationParameters {
    raw: RawIntegrationParameters

    constructor(raw?: RawIntegrationParameters) {
        this.raw = raw || new RawIntegrationParameters();
    }

    /**
     * Free the WASM memory used by these integration parameters.
     */
    public free() {
        this.raw.free();
        this.raw = undefined;
    }

    /**
     * The timestep length (default: `1.0 / 60.0`)
     */
    get dt(): number {
        return this.raw.dt;
    }

    /**
     * If `true`, the world's `step` method will stop right after resolving exactly one CCD event (default: `false`).
     * This allows the user to take action during a timestep, in-between two CCD events.
     */
    get returnAfterCcdSubstep(): boolean {
        return this.raw.returnAfterCcdSubstep;
    }

    /**
     * The Error Reduction Parameter in `[0, 1]` is the proportion of
     * the positional error to be corrected at each time step (default: `0.2`).
     */
    get erp(): number {
        return this.raw.erp;
    }

    /**
     * The Error Reduction Parameter for joints in `[0, 1]` is the proportion of
     * the positional error to be corrected at each time step (default: `0.2`).
     */
    get jointErp(): number {
        return this.raw.jointErp;
    }

    /**
     * Each cached impulse are multiplied by this coefficient in `[0, 1]`
     * when they are re-used to initialize the solver (default `1.0`).
     */
    get warmstartCoeff(): number {
        return this.raw.warmstartCoeff;
    }

    /**
     * Contacts at points where the involved bodies have a relative
     * velocity smaller than this threshold wont be affected by the restitution force (default: `1.0`).
     */
    get restitutionVelocityThreshold(): number {
        return this.raw.restitutionVelocityThreshold;
    }

    /**
     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).
     */
    get allowedLinearError(): number {
        return this.raw.allowedLinearError;
    }

    /**
     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).
     */
    get predictionDistance(): number {
        return this.raw.predictionDistance;
    }

    /**
     * Amount of angular drift of joint limits the engine wont
     * attempt to correct (default: `0.001rad`).
     */
    get allowedAngularError(): number {
        return this.raw.allowedAngularError;
    }

    /**
     * Maximum linear correction during one step of the non-linear position solver (default: `0.2`).
     */
    get maxLinearCorrection(): number {
        return this.raw.maxLinearCorrection;
    }

    /**
     * Maximum angular correction during one step of the non-linear position solver (default: `0.2`).
     */
    get maxAngularCorrection(): number {
        return this.raw.maxAngularCorrection;
    }

    /**
     * Maximum nonlinear SOR-prox scaling parameter when the constraint
     * correction direction is close to the kernel of the involved multibody's
     * jacobian (default: `0.2`).
     */
    get maxStabilizationMultiplier(): number {
        return this.raw.maxStabilizationMultiplier;
    }

    /**
     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).
     */
    get maxVelocityIterations(): number {
        return this.raw.maxVelocityIterations;
    }

    /**
     * Maximum number of iterations performed by the position-based constraints solver (default: `1`).
     */
    get maxPositionIterations(): number {
        return this.raw.maxPositionIterations;
    }

    /**
     * Minimum number of dynamic bodies in each active island (default: `128`).
     */
    get minIslandSize(): number {
        return this.raw.minIslandSize;
    }

    /**
     * Maximum number of iterations performed by the position-based constraints solver for CCD steps (default: `10`).
     *
     * This should be sufficiently high so all penetration get resolved. For example, if CCD cause your
     * objects to stutter, that may be because the number of CCD position iterations is too low, causing
     * them to remain stuck in a penetration configuration for a few frames.
     *
     * The highest this number, the highest its computational cost.
     */
    get maxCcdPositionIterations(): number {
        return this.raw.maxCcdPositionIterations;
    }

    /**
     * Maximum number of substeps performed by the  solver (default: `1`).
     */
    get maxCcdSubsteps(): number {
        return this.raw.maxCcdSubsteps;
    }

    /**
     * Controls the number of Proximity::Intersecting events generated by a trigger during CCD resolution (default: `false`).
     *
     * If false, triggers will only generate one Proximity::Intersecting event during a step, even
     * if another colliders repeatedly enters and leaves the triggers during multiple CCD substeps.
     *
     * If true, triggers will generate as many Proximity::Intersecting and Proximity::Disjoint/Proximity::WithinMargin
     * events as the number of times a collider repeatedly enters and leaves the triggers during multiple CCD substeps.
     */
    get multipleCcdSubstepSensorEventsEnabled(): boolean {
        return this.raw.multipleCcdSubstepSensorEventsEnabled;
    }

    /**
     * Whether penetration are taken into account in CCD resolution (default: `false`).
     *
     * If this is set to `false` two penetrating colliders will not be considered to have any time of impact
     * while they are penetrating. This may end up allowing some tunelling, but will avoid stuttering effect
     * when the constraints solver fails to completely separate two colliders after a CCD contact.
     *
     * If this is set to `true`, two penetrating colliders will be considered to have a time of impact
     * equal to 0 until the constraints solver manages to separate them. This will prevent tunnelling
     * almost completely, but may introduce stuttering effects when the constraints solver fails to completely
     * separate two colliders after a CCD contact.
     */
    get ccdOnPenetrationEnabled(): boolean {
        return this.raw.ccdOnPenetrationEnabled;
    }

    set dt(value: number) {
        this.raw.dt = value;
    }

    set returnAfterCcdSubstep(value: boolean) {
        this.raw.returnAfterCcdSubstep = value;
    }

    set erp(value: number) {
        this.raw.erp = value;
    }

    set jointErp(value: number) {
        this.raw.jointErp = value;
    }

    set warmstartCoeff(value: number) {
        this.raw.warmstartCoeff = value;
    }

    set restitutionVelocityThreshold(value: number) {
        this.raw.restitutionVelocityThreshold = value;
    }

    set allowedLinearError(value: number) {
        this.raw.allowedLinearError = value;
    }

    set predictionDistance(value: number) {
        this.raw.predictionDistance = value;
    }

    set allowedAngularError(value: number) {
        this.raw.allowedAngularError = value;
    }

    set maxLinearCorrection(value: number) {
        this.raw.maxLinearCorrection = value;
    }

    set maxAngularCorrection(value: number) {
        this.raw.maxAngularCorrection = value;
    }

    set maxStabilizationMultiplier(value: number) {
        this.raw.maxStabilizationMultiplier = value;
    }

    set maxVelocityIterations(value: number) {
        this.raw.maxVelocityIterations = value;
    }

    set maxPositionIterations(value: number) {
        this.raw.maxPositionIterations = value;
    }

    set minIslandSize(value: number) {
        this.raw.minIslandSize = value;
    }

    set maxCcdPositionIterations(value: number) {
        this.raw.maxCcdPositionIterations = value;
    }

    set maxCcdSubsteps(value: number) {
        this.raw.maxCcdSubsteps = value;
    }

    set multipleCcdSubstepSensorEventsEnabled(value: boolean) {
        this.raw.multipleCcdSubstepSensorEventsEnabled = value;
    }

    set ccdOnPenetrationEnabled(value: boolean) {
        this.raw.ccdOnPenetrationEnabled = value;
    }
}
