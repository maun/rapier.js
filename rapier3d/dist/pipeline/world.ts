import {
    RawBroadPhase, RawColliderSet,
    RawDeserializedWorld,
    RawIntegrationParameters,
    RawJointSet, RawNarrowPhase, RawPhysicsPipeline, RawQueryPipeline,
    RawRigidBodySet, RawSerializationPipeline,
    RawVector
} from "../raw";

import {
    BroadPhase,
    Collider, ColliderDesc,
    ColliderHandle,
    ColliderSet,
    NarrowPhase,
    Ray,
    RayColliderIntersection
} from "../geometry";
import {
    IntegrationParameters,
    Joint, JointHandle,
    JointParams,
    JointSet,
    RigidBody,
    RigidBodyDesc,
    RigidBodyHandle,
    RigidBodySet
} from "../dynamics";
import {Vector, VectorOps} from "../math";
import {PhysicsPipeline} from "./physics_pipeline";
import {QueryPipeline} from "./query_pipeline";
import {SerializationPipeline} from "./serialization_pipeline";
import {EventQueue} from "./event_queue";

/**
 * The physics world.
 *
 * This contains all the data-structures necessary for creating and simulating
 * bodies with contacts, joints, and external forces.
 */
export class World {
    gravity: Vector
    integrationParameters: IntegrationParameters
    broadPhase: BroadPhase
    narrowPhase: NarrowPhase
    bodies: RigidBodySet
    colliders: ColliderSet
    joints: JointSet
    queryPipeline: QueryPipeline
    physicsPipeline: PhysicsPipeline
    serializationPipeline: SerializationPipeline

    /**
     * Release the WASM memory occupied by this physics world.
     *
     * All the fields of this physics world will be freed as well,
     * so there is no need to call their `.free()` methods individually.
     */
    public free() {
        this.integrationParameters.free();
        this.broadPhase.free();
        this.narrowPhase.free();
        this.bodies.free();
        this.colliders.free();
        this.joints.free();
        this.queryPipeline.free();
        this.physicsPipeline.free();
        this.serializationPipeline.free();

        this.integrationParameters = undefined;
        this.broadPhase = undefined;
        this.narrowPhase = undefined;
        this.bodies = undefined;
        this.colliders = undefined;
        this.joints = undefined;
        this.queryPipeline = undefined;
        this.physicsPipeline = undefined;
        this.serializationPipeline = undefined;
    }

    constructor(
        gravity: Vector,
        rawIntegrationParameters?: RawIntegrationParameters,
        rawBroadPhase?: RawBroadPhase,
        rawNarrowPhase?: RawNarrowPhase,
        rawBodies?: RawRigidBodySet,
        rawColliders?: RawColliderSet,
        rawJoints?: RawJointSet,
        rawQueryPipeline?: RawQueryPipeline,
        rawPhysicsPipeline?: RawPhysicsPipeline,
        rawSerializationPipeline?: RawSerializationPipeline
    ) {
        this.gravity = gravity;
        this.integrationParameters = new IntegrationParameters(rawIntegrationParameters);
        this.broadPhase = new BroadPhase(rawBroadPhase);
        this.narrowPhase = new NarrowPhase(rawNarrowPhase);
        this.bodies = new RigidBodySet(rawBodies);
        this.colliders = new ColliderSet(rawColliders);
        this.joints = new JointSet(rawJoints);
        this.queryPipeline = new QueryPipeline(rawQueryPipeline);
        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);
        this.serializationPipeline = new SerializationPipeline(rawSerializationPipeline);
    }

    public static fromRaw(raw: RawDeserializedWorld): World {
        if (!raw)
            return null;

        return new World(
            VectorOps.fromRaw(raw.takeGravity()),
            raw.takeIntegrationParameters(),
            raw.takeBroadPhase(),
            raw.takeNarrowPhase(),
            raw.takeBodies(),
            raw.takeColliders(),
            raw.takeJoints(),
        );
    }

    /**
     * Takes a snapshot of this world.
     *
     * Use `World.restoreSnapshot` to create a new physics world with a state identical to
     * the state when `.takeSnapshot()` is called.
     */
    public takeSnapshot(): Uint8Array {
        return this.serializationPipeline.serializeAll(
            this.gravity,
            this.integrationParameters,
            this.broadPhase,
            this.narrowPhase,
            this.bodies,
            this.colliders,
            this.joints,
        );
    }

    /**
     * Creates a new physics world from a snapshot.
     *
     * This new physics world will be an identical copy of the snapshoted physics world.
     */
    public static restoreSnapshot(data: Uint8Array): World {
        let deser = new SerializationPipeline();
        return deser.deserializeAll(data);
    }

    /**
     * Advance the simulation by one time step.
     *
     * All events generated by the physics engine are ignored.
     *
     * @param EventQueue - (optional) structure responsible for collecting
     *   events generated by the physics engine.
     */
    public step(eventQueue?: EventQueue) {
        this.physicsPipeline.step(
            this.gravity,
            this.integrationParameters,
            this.broadPhase,
            this.narrowPhase,
            this.bodies,
            this.colliders,
            this.joints,
            eventQueue,
        );
        this.queryPipeline.update(this.bodies, this.colliders);
    }

    /**
     * The current simulation timestep.
     */
    get timestep(): number {
        return this.integrationParameters.dt;
    }

    /**
     * Sets the new simulation timestep.
     *
     * The simulation timestep governs by how much the physics state of the world will
     * be integrated. A simulation timestep should:
     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,
     * corresponds to the time between two frames of a game running at 60FPS).
     * - not vary too much during the course of the simulation. A timestep with large variations may
     * cause instabilities in the simulation.
     *
     * @param timestep - The timestep length, in milliseconds.
     */
    set timestep(dt: number) {
        this.integrationParameters.dt = dt;
    }

    /**
     * The maximum velocity iterations the velocity-based force constraint solver can make.
     */
    get maxVelocityIterations(): number {
        return this.integrationParameters.maxVelocityIterations;
    }

    /**
     * Sets the maximum number of velocity iterations (default: 4).
     *
     * The greater this value is, the most rigid and realistic the physics simulation will be.
     * However a greater number of iterations is more computationally intensive.
     *
     * @param niter - The new maximum number of velocity iterations.
     */
    set maxVelocityIterations(niter: number) {
        this.integrationParameters.maxVelocityIterations = niter;
    }

    /**
     * The maximum position iterations the position-based constraint regularization solver can make.
     */
    get maxPositionIterations(): number {
        return this.integrationParameters.maxPositionIterations;
    }

    /**
     * Sets the maximum number of position iterations (default: 1).
     *
     * The greater this value is, the less penetrations will be visible after one timestep where
     * the velocity solver did not converge entirely. Large values will degrade significantly
     * the performance of the simulation.
     *
     * To increase realism of the simulation it is recommanded, more efficient, and more effecive,
     * to increase the number of velocity iterations instead of this number of position iterations.
     *
     * @param niter - The new maximum number of position iterations.
     */
    set maxPositionIterations(niter: number) {
        this.integrationParameters.maxPositionIterations = niter;
    }

    /**
     * Creates a new rigid-body from the given rigd-body descriptior.
     *
     * @param body - The description of the rigid-body to create.
     */
    public createRigidBody(body: RigidBodyDesc): RigidBody {
        return this.bodies.get(this.bodies.createRigidBody(body));
    }

    /**
     * Creates a new collider.
     *
     * @param desc - The description of the collider.
     * @param parentHandle - The handle of the rigid-body this collider is attached to.
     */
    public createCollider(desc: ColliderDesc, parentHandle: RigidBodyHandle): Collider {
        return this.colliders.get(this.colliders.createCollider(this.bodies, desc, parentHandle));
    }

    /**
     * Creates a new joint from the given joint descriptior.
     *
     * @param joint - The description of the joint to create.
     * @param parent1 - The first rigid-body attached to this joint.
     * @param parent2 - The second rigid-body attached to this joint.
     */
    public createJoint(
        params: JointParams,
        parent1: RigidBody,
        parent2: RigidBody
    ): Joint {
        return this.joints.get(
            this.joints.createJoint(this.bodies, params, parent1.handle, parent2.handle)
        );
    }

    /**
     * Retrieves a rigid-body from its handle.
     *
     * @param handle - The integer handle of the rigid-body to retrieve.
     */
    public getRigidBody(handle: RigidBodyHandle): RigidBody {
        return this.bodies.get(handle);
    }

    /**
     * Retrieves a collider from its handle.
     *
     * @param handle - The integer handle of the collider to retrieve.
     */
    public getCollider(handle: ColliderHandle): Collider {
        return this.colliders.get(handle);
    }

    /**
     * Retrieves a joint from its handle.
     *
     * @param handle - The integer handle of the rigid-body to retrieve.
     */
    public getJoint(handle: JointHandle): Joint {
        return this.joints.get(handle);
    }

    /**
     * Removes the given rigid-body from this physics world.
     *
     * This will remove this rigid-body as well as all its attached colliders and joints.
     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.
     *
     * @param body - The rigid-body to remove.
     */
    public removeRigidBody(body: RigidBody) {
        this.physicsPipeline.removeRigidBody(
            body.handle,
            this.broadPhase,
            this.narrowPhase,
            this.bodies,
            this.colliders,
            this.joints,
        );
    }

    /**
     * Removes the given collider from this physics world.
     *
     * The rigid-body this collider is attached to will be woken-up.
     *
     * @param body - The collider to remove.
     */
    public removeCollider(collider: Collider) {
        this.physicsPipeline.removeCollider(
            collider.handle,
            this.broadPhase,
            this.narrowPhase,
            this.bodies,
            this.colliders,
        );
    }

    /**
     * Applies the given closure to each collider managed by this physics world.
     *
     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.
     */
    public forEachCollider(f: (collider: Collider) => void) {
        this.colliders.forEachCollider(f)
    }

    /**
     * Applies the given closure to the integer handle of each collider managed by this physics world.
     *
     * @param f(handle) - The function to apply to the integer handle of each collider managed by this physics world. Called as `f(collider)`.
     */
    public forEachColliderHandle(f: (handle: ColliderHandle) => void) {
        this.colliders.forEachColliderHandle(f)
    }

    /**
     * Applies the given closure to each rigid-body managed by this physics world.
     *
     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.
     */
    public forEachRigidBody(f: (body: RigidBody) => void) {
        this.bodies.forEachRigidBody(f)
    }

    /**
     * Applies the given closure to the integer handle of each rigid-body managed by this physics world.
     *
     * @param f(handle) - The function to apply to the integer handle of each rigid-body managed by this physics world. Called as `f(collider)`.
     */
    public forEachRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {
        this.bodies.forEachRigidBodyHandle(f)
    }

    /**
     * Applies the given closure to each active rigid-body managed by this physics world.
     *
     * After a short time of inactivity, a rigid-body is automatically deactivated ("asleep") by
     * the physics engine in order to save computational power. A sleeping rigid-body never moves
     * unless it is moved manually by the user.
     *
     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.
     */
    public forEachActiveRigidBody(f: (body: RigidBody) => void) {
        this.bodies.forEachActiveRigidBody(f);
    }

    /**
     * Applies the given closure to the integer handle of each active rigid-body
     * managed by this physics world.
     *
     * After a short time of inactivity, a rigid-body is automatically deactivated ("asleep") by
     * the physics engine in order to save computational power. A sleeping rigid-body never moves
     * unless it is moved manually by the user.
     *
     * @param f(handle) - The function to apply to the integer handle of each active rigid-body managed by this
     *   physics world. Called as `f(collider)`.
     */
    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {
        this.bodies.forEachActiveRigidBodyHandle(f);
    }

    /**
     * Cast a ray against this physics world and return the first collider it hits.
     *
     * This returns null if no hit is found.
     *
     * @param ray - The ray to cast.
     * @param max_toi - The maximum time-of-impact that can be reported by this cast. This effectively
     *   limits the length of the ray to `ray.dir.norm() * max_toi`. Use `f32::MAX` for an
     *   unbounded ray.
     */
    public castRay(ray: Ray, maxToi: number): RayColliderIntersection {
        return this.queryPipeline.castRay(this.colliders, ray, maxToi);
    }
}
